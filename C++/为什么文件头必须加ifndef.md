# 为什么文件头必须加#ifndef

C++头文件为什么要加#ifndef #define #endif
#ifndef 在头文件中的作用
在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件时，就会出现大量“重定义”的错误。在头文件中实用#ifndef #define #endif能避免头文件的重定义。
方法：例如要编写头文件test.h,在头文件开头写上两行：
```
#ifndef _TEST_H
#define _TEST_H                 //一般是文件名的大写
```
头文件结尾写上一行：
```
#endif
```
这样一个工程文件里同时包含两个test.h时，就不会出现重定义的错误了。
分析：当第一次包含test.h时，由于没有定义_TEST_H，条件为真，这样就会包含（执行）#ifndef _TEST_H和#endif之间的代码，当第二次包含test.h时前面一次已经定义了_TEST_H，条件为假，#ifndef _TEST_H和#endif之间的代码也就不会再次被包含，这样就避免了重定义了。
```
#ifndef __74HC595_H__
#define __74HC595_H__
#endif
 
#ifndef _optimizedvector_h        // if not define _optimizedvector_h
#define _optimizedvector_h           // then define _optimizedvector_h
```
通俗点就是如果没定义_optimizedvector_h，那就定义_optimizedvector_h，防止重复编译。头文件中的#ifndef，这是一个很关键的东西。比如你有两个C文件，这两个C文件都include了同一个头文件。而编译时，这两个C文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突。
 还是把头文件的内容都放在#ifndef和#endif中吧。不管你的头文件会不会被多个文件引用，你都要加上这个。一般
 格式是这样的：
```
#ifndef <标识>
#define <标识>
......
#endif
```
<标识>在理论上来说可以是自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的命名规则一般是头文件名全大写，前后加下划线，并把文件名中的“.”也变成下划线，
 如：stdio.h
```
#ifndef _STDIO_H_
#define _STDIO_H_
......
#endif
```
在#ifndef中定义变量出现的问题（一般不定义在#ifndef中）。
```
#ifndef AAA
#define AAA
...
int i;
...
#endif
```
里面有一个变量定义
在vc中链接时就出现了i重复定义的错误，而在c中成功编译。
 
结论：
(1).当你第一个使用这个头的.cpp文件生成.obj的时候，int i 在里面定义了当另外一个使用这个的.cpp再次[单独]生成.obj的时候，int i 又被定义然后两个obj被另外一个.cpp也include 这个头的，连接在一起，就会出现重复定义.
(2).把源程序文件扩展名改成.c后，VC按照C语言的语法对源程序进行编译，而不是C++。在C语言中，若是遇到多个int i，则自动认为其中一个是定义，其他的是声明。
(3).C语言和C++语言连接结果不同，可能（猜测）时在进行编译的时候，C++语言将全局变量默认为强符号，所以连接出错。C语言则依照是否初始化进行强弱的判断的。（参考）
解决方法：
(1).把源程序文件扩展名改成.c。
(2).推荐解决方案：
.h中只声明 extern int i;在.cpp中定义
```
<x.h>
#ifndef __X_H__
#define __X_H__
extern int i;
#endif //__X_H__
< x.c>
int i;
```
注意问题：
(1).变量一般不要定义在.h文件中。一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。
条件编译命令最常见的形式为：
```
#ifdef 标识符
程序段1
#else
程序段2
#endif
```
它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。其中#else部分也可以没有，即：
```
#ifdef
程序段1
#denif
```
这里的“程序段”可以是语句组，也可以是命令行。这种条件编译可以提高C源程序的通用性。如果一个C源程序在不同计算机系统上系统上运行，而不同的计算机又有一定的差异。例如，我们有一个数据类型，在Windows平台中，应该使用long类型表示，而在其他平台应该使用float表示，这样往往需要对源程序作必要的修改，这就降低了程序的通用性。可以用以下的条件编译：
```
#ifdef WINDOWS
#define MYTYPE long
#else
#define MYTYPE float
#endif
```
如果在Windows上编译程序，则可以在程序的开始加上
```
#define WINDOWS
```
这样则编译下面的命令行：
```
#define MYTYPE long
```
如果在这组条件编译命令之前曾出现以下命令行： #define WINDOWS 0

则预编译后程序中的MYTYPE都用float代替。这样，源程序可以不必作任何修改就可以用于不同类型的计算机系统。

例如，在调试程序时，常常希望输出一些所需的信息，而在调试完成后不再输出这些信息。可以在源程序中插入以
下的条件编译段：
```
#ifdef DEBUG
print ("device_open(%p) ", file);
#endif
```
如果在它的前面有以下命令行: #define DEBUG则在程序运行时输出file指针的值，以便调试分析。调试完成后只需将这个define命令行删除即可。有人可能觉得不用条件编译也可达此目的，即在调试时加一批printf语句，调试后一一将printf语句删除去。的确，这是可以的。但是，当调试时加的printf语句比较多时，修改的工作量是很大的。用条件编译，则不必一一删改printf语句，只需删除前面的一条“#define DEBUG”命令即可，这时所有的用DEBUG作标识符的条件编译段都使其中的printf语句不起作用，即起统一控制的作用，如同一个“开关”一样。有时也采用下面的形式：
```
#ifndef 标识符
程序段1
#else
程序段2
#endif
```
只是第一行与第一种形式不同：将“ifdef”改为“ifndef”。它的作用是：若标识符未被定义则编译程序段1，否则编译程序段2。这种形式与第一种形式的作用相反。

以上两种形式用法差不多，根据需要任选一种，视方便而定。
还有一种形式，就是#if后面的是一个表达式，而不是一个简单的标识符：
```
#if 表达式
程序段1
#else
程序段2
#endif
```
它的作用是：当指定的表达式值为真（非零）时就编译程序段1，否则编译程序段2。可以事先给定一定条件，使程序在不同的条件下执行不同的功能。作用范围就是当前文件啊。因为编译是以cpp或c文件位单位的嘛。还以这个为例：
```
//正常代码
#ifdef _DEBUG
TRACE("Some infomation");
#else
//Now is release version,so do nothing
#endif
//正常代码
```
编译时是先把所有的预编译处理展开（比如宏）再编译，所以Debug模式下，编译时的代码是：
```
//正常代码
TRACE("Some infomation");
//正常代码
```
Release模式下的代码是：
```
//正常代码
//正常代码
```