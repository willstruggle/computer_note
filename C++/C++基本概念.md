# C++基本概念

## 1. 面向对象
1、继承 多态 封装 理解概念
2、initializ_list模板类用于接收可变参数形参。
3、内联函数不能有复杂for循环 switch，都是比较简单的逻辑
4、函数重载

## 2. 类与对象
### 2.1. 面向对象程序设计的基本特点
1、同一类对象的共同属性和行为进行概括形成类。数据抽象和代码抽象
2、protect用于有继承关系的类
3、在类中说明函数原型，在类外给出函数实现，，也可以在类中给出函数体，形成内联成员函数，允许声明重载函数和带默认参数的函数。
### 2.2. 构造函数
1、构造函数用于对基本数据进行初始化。构造函数名字和类名一样，不能有返回值。可以内联，可以重载，可以有形参。自动被调用
简单赋值 的构造函数直接在参数赋值。
如果自己定义了构造函数，编译器不会生成默认构造函数，需要自己定一个默认构造函数。所以在想偷懒的情况下，可以让构造函数=default（这样系统可以按需是否生成构造函数）；
委托构造函数使用类的其他构造函数执行初始化流程
2、复制构造函数
=delete 指示编译器不生成默认复制构造函数，特殊情况下才有用
3、移动构造函数
move可以将左值对象移动为右值
移动构造函数，节省构造函数允许空间，主要是将将死的对象移动转化为右值，并赋值，后续就会被自动销毁。
4、类组合
类中的成员是另一个类的对象。复制构造函数调用的情况比较复杂。
前向引用声明。用于类的互相调用。
在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象。当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。

## 3. 数据共享
### 3.1. 作用域
限定作用域的枚举类型。解决名字重复。
内层标识符会覆盖外层标识符
对象生存期，static静态生存期，没有static修饰的都是动态生存期
### 3.2. 对象间共享数据
同类数据共享：静态数据成员。static修饰，为该类的所有对象共享，一般在类内声明，类外定义。后构造的对象先析构
同类功能共享：静态成员函数，主要用于处理该类的静态数据成员。
类与外部数据共享：友元，单向的授权关系。让外部函数使用private数据，破坏数据封装和数据隐藏的机制。尽量少用。用常引用做形参。
### 3.3. 共享数据的保护
函数常成员：不改变对象状态的成员函数声明为常函数
常对象定义之后调用对应成员函数，需要对应声明常函数成员。。
数据常成员：常数据成员只能通过初始化列表赋值。
常引用：常引用做形参，引用不发生赋值构造，且不修改数据。


## 4. 数组指针字符串
### 4.1. 指针
指向常量的指针，用于传递参数的时候，不希望改变指针指向的内容
指针类型的常量：若指针常量，则指针本身的值不变。
与数组相关的指针应用
指针数组
与函数、对象相关的指针应用
指针类型的函数：不要将局部变量地址作为返回值返回。
指向函数的指针：函数指针指向的是程序代码存储区，指针函数可以用于C语言实现函数回调。
this指针：隐藏在类中每一个非静态成员函数中

### 4.2. 动态内存分配

## 5. 类的继承
### 5.1. 继承与派生的目的
继承：实现设计与代码的重用
派生：当新问题出现，原有程序无法解决，需要对原有程序进行改造
吸收基类成员
改造基类成员：声明同名新成员，隐藏和覆盖外层同名成员。
添加新的成员

### 5.2. 不同继承方式的影响
三种继承方式：
公有继承：继承public和protect成员，但是不能直接访问基类private成员。保护成员在本类中是私有的。
私有继承：基类的public和protected成员都以private身份继承，还是不能直接访问基类private成员。觉得基类有很多函数对于写派生类有帮助，但是写的派生类提供完全与基类不同的服务，则可以采用私有继承。
保护继承：基类的public和protected成员都以protected身份出现在派生类，还是不能访问private成员。子孙还可以继续使用。

千万不要重新定义继承来的非虚函数。

### 5.3. 派生类对象构造与析构
基类构造函数不能继承，派生类需要自己写
只需要对新增成员进行初始化。对继承来的基类成员初始化，自动调用基类构造函数。
派生类构造函数需要给基类的构造函数传递参数
using语句继承基类构造函数 using base::base

先构造基类，再构造子类，先析构子类，再析构基类。
### 5.4. 虚基类
虚基类，在第一及继承声明虚继承。加一个virtual
用于解决基类的数据成员被重复继承，冗余数据存储，不造成歧义。
虚继承，构造函数还要给最远虚基类传递参数。
当到了不可控的范围，虚继承并不完美，需要每一级虚继承，且需要对最远基类进行传参。

## 6. 多态
### 6.1. 运行时多多态
通过虚函数实现运行时多态，虚函数都不能是内联函数
虚函数是实现运行时多态的基础
每一个多态类都有一个虚表 
派生类的同名函数一般也要加virtual（可以不加，但是加了增加程序可读性）

非静态成员函数，构造函数不能是虚函数，析构函数可以是虚函数（最好是虚函数）
析构函数是虚函数，这样就能先执行派生类的虚函数再执行基类的虚函数。

有纯虚函数（=0）的类称为抽象类（只要有一个就是抽象类），要求各派生类覆盖，抽象类不能实例化。定义基类的时候过于抽象，可以先不实现，定义为纯虚函数，后面派生类再实现，规范整个类家族的行为，派生类都需要实现这个功能，抽象类只能作为基类。

override显式覆盖，提醒编译器，我这个一定要在派生类覆盖
final 定义类或者函数不允许被继承，认为这个函数很重要，不允许派生类覆盖

### 6.2. 运算符重载
对已有的运算符赋予不同的含义。如复数类的对象可以用“+”运算符实现加法。让自己实现的类实现运算。
左操作数必须是类的对象，否则只能通过友元用全局定义重载。
临时变量不能用引用返回。

## 7. 模板
### 7.1. 函数模板和类模板
template<typename T>
template<class T>
模板参数还可以是常量，模板里可以用这个常数
...
类型可以作为参数，类型可定制。
数组、列表、栈、队列

### 7.2. 线性群体


## 8. 泛型编程
### 8.1. 泛型程序设计及STL
不依赖与具体数据类型的程序
C++ STL用概念来界定一定功能的数据类型： compareable，Assigable，如果既可比较又可赋值，则sortable，可排序。
template<typename Sortable>

### 8.2. STL基本组件
容器（容纳一组数据）：
顺序容器：
array数组：对象大小固定，定义时需要制定大小
vector向量：可随机访问，在尾部插入和删除元素快，中间头部插入元素慢。s.reserve()保留容量，s.capacity()返回实际分配空间大小。 s.srink_to_fit()：回收未使用空间，使得size和capacity相等。
deque双端队列：在两端插入删除快，中间插入删除慢，可以随机访问。
forward_list单链表：不支持size操作
list列表：任意位置插入和删除元素很快，不支持随机访问，拼接操作很合适。

默认构造函数三种 S s(n,t) S s(n)  S s(p,q)
s.emplace(p1,args)，将args作为T的构造函数构造新元素t，插入

顺序容器的插入迭代器：front_insterter iter(s) back_inserter,任意位置插入 

关联容器：set集合、multiset多重集合、map映射、multimap，是否允许重复分为multi
无需关联容器：unordered_set ...
容器适配器（栈、队列、优先队列（最大元素先弹出），对已有容器加一些限制），栈和队列不支持迭代器。
begin()、cbegin()是常容器不改变内容、rbegin()逆向迭代器
迭代器类型S::iterator、S::const_iterator
逆向迭代器S::reverse_iterator

迭代器（用来遍历容器的地址，因为容器是封装起来的，所以需要迭代器把容器内容取出来）：提供顺序容器中访问每个元素的方法，泛化的指针，使用独立于STL容器的迭代器需要包含<iterator>
输入流迭代器istream_iterator<T>
输出流迭代器ostream_iterator<T>
transform(..)
advance(p,n)，迭代器自增n
distance(first,last)，迭代器之间距离

算法:STL包含70多个算法，如排序。需要头文件<algotithm>

函数对象（是算法的参数）:行为类似函数的对象，STL函数对象需要包含<functional>


